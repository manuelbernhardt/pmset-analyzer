#!/usr/bin/env python3
"""
pmset-analyzer: Analyze macOS sleep logs from `pmset -g log` output

This script parses sleep logs generated by running `pmset -g log > sleep-log.txt` on macOS
and provides statistics about wake-up events and their causes.

Copyright 2025 pmset-analyzer contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import argparse
import re
import sys
from collections import defaultdict, Counter
from datetime import datetime
from typing import Dict, List, Tuple, Optional, TextIO


class SleepLogAnalyzer:
    """Analyzer for macOS pmset sleep logs."""
    
    def __init__(self, log_input: Optional[str] = None, verbose: bool = False):
        self.log_input = log_input
        self.verbose = verbose
        self.wake_events: List[Dict] = []
        self.driver_reasons: Counter = Counter()
        self.wake_types: Counter = Counter()
        self.timestamps: List[datetime] = []
        self.wake_cause_examples: Dict[str, List[str]] = defaultdict(list)
        
    def parse_log(self) -> None:
        """Parse the sleep log input and extract wake events and driver reasons."""
        current_wake_event = None
        driver_reasons_buffer = []
        
        if self.log_input:
            with open(self.log_input, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
        else:
            lines = sys.stdin.readlines()
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            # Skip empty lines and headers
            if not line or line.startswith('=') or 'Time stamp' in line or 'Duration' in line:
                i += 1
                continue
            
            # Match timestamped entries
            timestamp_match = re.match(r'^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} [+-]\d{4})\s+(\w+)\s+(.+)$', line)
            
            if timestamp_match:
                timestamp_str, event_type, message = timestamp_match.groups()
                
                try:
                    # Parse timestamp - handle both + and - timezone offsets
                    if ' +' in timestamp_str:
                        date_part, tz_part = timestamp_str.split(' +')
                        timestamp = datetime.strptime(date_part, '%Y-%m-%d %H:%M:%S')
                    elif ' -' in timestamp_str:
                        date_part, tz_part = timestamp_str.split(' -')
                        timestamp = datetime.strptime(date_part, '%Y-%m-%d %H:%M:%S')
                    else:
                        timestamp = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')
                except ValueError:
                    # If timestamp parsing fails, skip this entry
                    i += 1
                    continue
                
                self.timestamps.append(timestamp)
                
                # Process wake events
                if event_type == 'DarkWake' and 'from Deep Idle' in message:
                    # Save previous wake event if exists
                    if current_wake_event:
                        current_wake_event['driver_reasons'] = driver_reasons_buffer.copy()
                        self.wake_events.append(current_wake_event)
                        driver_reasons_buffer.clear()
                    
                    # Extract wake details
                    wake_match = re.search(r'DarkWake from ([^:]+).*?due to (.+?)(?:\s+Using|\s+\d+\s+secs|$)', message)
                    if wake_match:
                        wake_source, causes = wake_match.groups()
                        duration_match = re.search(r'(\d+)\s+secs', message)
                        duration = int(duration_match.group(1)) if duration_match else 0
                        
                        current_wake_event = {
                            'timestamp': timestamp,
                            'wake_source': wake_source.strip(),
                            'causes': causes.strip(),
                            'duration': duration,
                            'driver_reasons': []
                        }
                        
                        self.wake_types[wake_source.strip()] += 1
                        
                        # Count individual causes and store examples
                        cause_list = re.split(r'\s+', causes.strip())
                        for cause in cause_list:
                            if cause and cause != '/':
                                self.driver_reasons[cause] += 1
                                # Store example lines for verbose output (limit to 3 examples per cause)
                                if self.verbose and len(self.wake_cause_examples[cause]) < 3:
                                    self.wake_cause_examples[cause].append(f"{timestamp_str} {event_type}: {message}")
                
                elif event_type == 'WakeDetails' and current_wake_event:
                    # This line starts the driver details section
                    # Look ahead to collect all DriverReason lines
                    j = i + 1
                    while j < len(lines):
                        next_line = lines[j].strip()
                        if next_line.startswith('DriverReason:'):
                            driver_match = re.match(r'DriverReason:([^-]+)', next_line)
                            if driver_match:
                                driver_name = driver_match.group(1).strip()
                                driver_reasons_buffer.append(driver_name)
                                self.driver_reasons[driver_name] += 1
                                # Store example DriverReason lines for verbose output
                                if self.verbose and len(self.wake_cause_examples[driver_name]) < 3:
                                    self.wake_cause_examples[driver_name].append(f"DriverReason: {next_line}")
                        elif re.match(r'^\d{4}-\d{2}-\d{2}', next_line):
                            # Next timestamped entry, break
                            break
                        j += 1
                    i = j - 1  # Adjust index to continue from the right position
            
            i += 1
        
        # Don't forget the last wake event
        if current_wake_event:
            current_wake_event['driver_reasons'] = driver_reasons_buffer.copy()
            self.wake_events.append(current_wake_event)
    
    def print_analysis(self) -> None:
        """Print comprehensive analysis of the sleep log."""
        if not self.wake_events:
            print("No wake events found in the log file.")
            return
        
        print("=== macOS Sleep Log Analysis ===\n")
        
        # Basic stats
        print(f"📊 Total wake events: {len(self.wake_events)}")
        if self.timestamps:
            print(f"📅 Log period: {min(self.timestamps)} to {max(self.timestamps)}")
        print()
        
        # Wake sources breakdown
        print("🔍 Wake Sources:")
        for source, count in self.wake_types.most_common():
            percentage = (count / len(self.wake_events)) * 100
            print(f"  • {source}: {count} times ({percentage:.1f}%)")
        print()
        
        # Top wake causes (drivers/reasons)
        print("🚨 Top Wake Causes:")
        for cause, count in self.driver_reasons.most_common(10):
            percentage = (count / sum(self.driver_reasons.values())) * 100
            print(f"  • {cause}: {count} times ({percentage:.1f}%)")
            
            # Show example log lines in verbose mode
            if self.verbose and cause in self.wake_cause_examples:
                print(f"    📝 Example log entries:")
                for example in self.wake_cause_examples[cause]:
                    # Truncate very long lines for readability
                    if len(example) > 100:
                        example = example[:97] + "..."
                    print(f"       {example}")
                print()
        print()
        
        # Wake duration analysis
        durations = [event['duration'] for event in self.wake_events if event['duration'] > 0]
        if durations:
            avg_duration = sum(durations) / len(durations)
            print(f"⏱️  Average wake duration: {avg_duration:.1f} seconds")
            print(f"🔄 Shortest wake: {min(durations)} seconds")
            print(f"⏰ Longest wake: {max(durations)} seconds")
            print()
        
        # Frequent wake patterns
        print("🔄 Wake Frequency Analysis:")
        if len(self.wake_events) > 1:
            intervals = []
            for i in range(1, len(self.wake_events)):
                interval = (self.wake_events[i]['timestamp'] - self.wake_events[i-1]['timestamp']).total_seconds()
                intervals.append(interval)
            
            if intervals:
                avg_interval = sum(intervals) / len(intervals)
                print(f"  • Average time between wakes: {avg_interval/60:.1f} minutes")
                
                # Count short intervals (< 5 minutes)
                short_intervals = [i for i in intervals if i < 300]
                if short_intervals:
                    print(f"  • Frequent wakes (< 5 min apart): {len(short_intervals)} occurrences")
        print()
        
        # Most problematic drivers
        print("⚠️  Most Active Drivers/Components:")
        driver_groups = defaultdict(int)
        for driver, count in self.driver_reasons.most_common():
            if 'smc' in driver.lower():
                driver_groups['SMC (System Management Controller)'] += count
            elif 'wifi' in driver.lower() or 'bluetooth' in driver.lower():
                driver_groups['Wireless (WiFi/Bluetooth)'] += count
            elif 'usb' in driver.lower():
                driver_groups['USB Devices'] += count
            elif 'audio' in driver.lower():
                driver_groups['Audio System'] += count
            else:
                driver_groups['Other'] += count
        
        for category, count in sorted(driver_groups.items(), key=lambda x: x[1], reverse=True):
            percentage = (count / sum(self.driver_reasons.values())) * 100
            print(f"  • {category}: {count} wake events ({percentage:.1f}%)")
        print()
        
        # Recent wake events (last 10)
        print("📋 Recent Wake Events:")
        recent_events = sorted(self.wake_events, key=lambda x: x['timestamp'], reverse=True)[:10]
        for event in recent_events:
            causes_str = event['causes'][:50] + '...' if len(event['causes']) > 50 else event['causes']
            print(f"  • {event['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}: {causes_str} ({event['duration']}s)")


def main():
    """Main entry point for the pmset-analyzer."""
    parser = argparse.ArgumentParser(
        description='Analyze macOS sleep logs from pmset -g log output',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s sleep-log.txt
  pmset -g log > my-sleep-log.txt && %(prog)s my-sleep-log.txt
  pmset -g log | %(prog)s
        """
    )
    
    parser.add_argument(
        'log_file',
        nargs='?',
        help='Path to the sleep log file (generated by: pmset -g log > logfile.txt). If not provided, reads from stdin.'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    
    args = parser.parse_args()

    
    try:
        analyzer = SleepLogAnalyzer(args.log_file, verbose=args.verbose)
        if args.verbose:
            if args.log_file:
                print(f"Parsing log file: {args.log_file}")
            else:
                print("Parsing log data from stdin...")
        
        analyzer.parse_log()
        analyzer.print_analysis()
        
    except FileNotFoundError:
        print(f"Error: Could not find log file '{args.log_file}'")
        print("Generate a log file with: pmset -g log > sleep-log.txt")
        return 1
    except Exception as e:
        print(f"Error analyzing log file: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1
    
    return 0


if __name__ == '__main__':
    exit(main()) 